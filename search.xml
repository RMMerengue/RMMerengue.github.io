<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux常用操作</title>
      <link href="2021/03/17/linux-chang-yong-cao-zuo/"/>
      <url>2021/03/17/linux-chang-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><h4 id="1-1-关机"><a href="#1-1-关机" class="headerlink" title="1.1 关机"></a>1.1 关机</h4><ul><li>shutdown -h now 立刻关机</li><li>shutdown -h 5 五分钟后关机</li><li>poweroff 立刻关机</li></ul><h4 id="1-2-重启"><a href="#1-2-重启" class="headerlink" title="1.2 重启"></a>1.2 重启</h4><ul><li>shutdown -r now 立刻重启</li><li>shutdown -r 5 五分钟后重启</li><li>reboot 立刻重启</li></ul><h4 id="1-3-帮助命令"><a href="#1-3-帮助命令" class="headerlink" title="1.3 帮助命令"></a>1.3 帮助命令</h4><ul><li><p>–help命令<br>  ifconfig  –help：查看网卡信息</p></li><li><p>man命令（命令说明书）<br>man shutdown<br>注意：man shutdown打开命令说明书之后，使用按键q退出</p></li></ul><hr><h2 id="2-目录操作"><a href="#2-目录操作" class="headerlink" title="2.目录操作"></a>2.目录操作</h2><h4 id="2-1-目录切换"><a href="#2-1-目录切换" class="headerlink" title="2.1 目录切换"></a>2.1 目录切换</h4><ul><li>cd / 切换到根目录</li><li>cd /usr 切换到根目录下的usr目录</li><li>cd ../ 切换到上一级目录 或者  cd ..</li><li>cd ~ 切换到home目录</li><li>cd - 切换到上次访问的目录</li></ul><h4 id="2-2-目录查看"><a href="#2-2-目录查看" class="headerlink" title="2.2 目录查看"></a>2.2 目录查看</h4><ul><li>ls 查看当前目录下的所有目录和文件</li><li>ls -a&nbsp;查看当前目录下的所有目录和文件（包括隐藏的文件）</li><li>ls -l 或 ll 列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）</li><li>ls /dir&nbsp;查看指定目录下的所有目录和文件 &nbsp; 如：ls /usr</li></ul><h4 id="2-3-创建操作"><a href="#2-3-创建操作" class="headerlink" title="2.3 创建操作"></a>2.3 创建操作</h4><ul><li>mkdir aaa 在当前目录下创建一个名为aaa的目录</li><li>mkdir /usr/aaa 在指定目录下创建一个名为aaa的目录</li></ul><h4 id="2-4-删除操作"><a href="#2-4-删除操作" class="headerlink" title="2.4 删除操作"></a>2.4 删除操作</h4><ul><li>rm 文件 删除当前目录下的文件</li><li>rm -f 文件 删除当前目录的的文件（不询问）</li><li>rm -r aaa 递归删除当前目录下的aaa目录</li><li>rm -rf aaa 递归删除当前目录下的aaa目录（不询问）</li><li>rm -rf * 将当前目录下的所有目录和文件全部删除</li><li>rm -rf /* 【慎用】将根目录下的所有文件全部删</li></ul><h4 id="2-5-修改操作"><a href="#2-5-修改操作" class="headerlink" title="2.5 修改操作"></a>2.5 修改操作</h4><ul><li>mv 当前目录 新目录 重命名目录</li><li>mv 目录名称 目录的新位置 剪切目录</li><li>cp -r 目录名称 目录拷贝的目标位置   -r代表递归</li></ul><h4 id="2-5-查找操作"><a href="#2-5-查找操作" class="headerlink" title="2.5 查找操作"></a>2.5 查找操作</h4><ul><li>find 目录 参数 文件名称  </li></ul><hr><h2 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3.文件操作"></a>3.文件操作</h2><h4 id="3-1-新建文件"><a href="#3-1-新建文件" class="headerlink" title="3.1 新建文件"></a>3.1 新建文件</h4><ul><li>touch 文件名</li></ul><h4 id="3-2-修改文件（vi）"><a href="#3-2-修改文件（vi）" class="headerlink" title="3.2 修改文件（vi）"></a>3.2 修改文件（vi）</h4><p>基本上vi可以分为三种状态，分别是<strong>命令模式（command mode）</strong>、<strong>插入模式（Insertmode）</strong>和<strong>底行模式（last line mode）</strong>，各模式的功能区分如下：</p><h5 id="3-2-1-命令行模式-command-mode）"><a href="#3-2-1-命令行模式-command-mode）" class="headerlink" title="3.2.1 命令行模式(command mode）"></a>3.2.1 命令行模式(command mode）</h5><ul><li>i o a 进入编辑模式</li><li>: 进入底行模式</li><li>[n]dd 删除当前行开始的n行</li><li>[n]yy 复制当前行开始的n行</li><li>p 把粘贴板上的内容插入到当前行</li><li>. 执行上一次操作</li><li>u 撤销前一个操作</li><li>Ctrl+f/Ctrl+b 向前、后滚动一个屏幕 </li><li>gg 到文件第一行行首</li><li>G 到文件最后一行行首</li><li>[n]G/[n]gg 到指定行</li><li>gg=G 自动缩进</li><li>/字符 查找字符</li></ul><h5 id="3-2-2-编辑模式（Insert-mode）"><a href="#3-2-2-编辑模式（Insert-mode）" class="headerlink" title="3.2.2 编辑模式（Insert mode）"></a>3.2.2 编辑模式（Insert mode）</h5><ul><li>ESC 退出编辑模式到命令行模式</li></ul><h5 id="3-2-3-底行模式（last-line-mode）"><a href="#3-2-3-底行模式（last-line-mode）" class="headerlink" title="3.2.3 底行模式（last line mode）"></a>3.2.3 底行模式（last line mode）</h5><ul><li>退出编辑：:q</li><li>强制退出：:q!</li><li>保存并退出：:wq</li></ul><hr><h2 id="4-压缩文件操作"><a href="#4-压缩文件操作" class="headerlink" title="4.压缩文件操作"></a>4.压缩文件操作</h2><h4 id="4-1-打包和压缩"><a href="#4-1-打包和压缩" class="headerlink" title="4.1 打包和压缩"></a>4.1 打包和压缩</h4><ul><li>tar -zcvf 打包压缩后的文件名 要打包的文件（z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名）</li></ul><h4 id="4-2-解压"><a href="#4-2-解压" class="headerlink" title="4.2 解压"></a>4.2 解压</h4><ul><li>tar -zxvf 解压文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes of Deep Learning Lessons:L4-CNN-Obeject Detection</title>
      <link href="2020/12/14/object-dtection/"/>
      <url>2020/12/14/object-dtection/</url>
      
        <content type="html"><![CDATA[<h2 id="OverFeat"><a href="#OverFeat" class="headerlink" title="OverFeat"></a>OverFeat</h2><ul><li>This paper shows that different task can be learned <strong>simultaneously</strong> using <strong>a single shared network</strong>.</li><li>It is the first to provide a clear explantion <strong>how ConVNets can be used</strong> for <strong>localization</strong> and <strong>detection</strong> for ImageNet data.</li><li><strong>Multi-scale classification</strong> not only ignores some <strong>regions of the image</strong>, but also be <strong>comutationaly redundant</strong> if views <strong>overlap</strong>.</li><li>While the sliding window approach may be <strong>computationaly prohibitive</strong> for certain types of models, it is <strong>inherently efficient</strong> in the case of ConVNets, this approach yields significantly more views for voting, which increases <strong>robustness</strong> while remaining <strong>computationaly efficient</strong>.</li><li>The paper also shows a <strong>multi-scale sliding window</strong> approach that can be used for <strong>classification</strong>, <strong>localization</strong> and <strong>detection</strong>.</li></ul><hr><h2 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h2><ul><li>YOLO frame object detection as <strong>a regression problem</strong> to <strong>spatially separated bounding boxes</strong> and <strong>associated class probabilities</strong>.</li><li>A single neural predicts <strong>bounding boxes</strong> and <strong>class probabilities</strong> directly from full images in <strong>one</strong> evaluation.</li><li>Compared to state-of-the-art detectionsystems, YOLO <strong>makes more localization errors</strong> but is <strong>less likely to predict false positives on background</strong>.</li><li><strong>Limitations</strong> of YOLO are as follows:  </li></ul><ol><li>YOLO imposes strong <strong>spatial constraints</strong> on bounding box predictions since each grid cell predicts <strong>two boxes</strong> and can only have <strong>one class</strong>. This spatial constraints limits the <strong>number of nearby objects</strong> that our model can predict. YOLO struggles with small objects that <strong>appear in groups</strong>, such as flocks of birds.  </li><li>Since YOLO learns to predict bounding boxes from <strong>data</strong>, it struggles to generalize to objects in <strong>new</strong> or <strong>unusual aspect ratio</strong> or <strong>configurations</strong>.  </li><li>While YOLO train on a loss function that approximates detection performance, loss function treats errors the same in <strong>small bounding boxes</strong> versus <strong>large bounding boxes</strong>.<strong>A small error in a large box</strong> is generally benign but <strong>a small error in a small box</strong> has a much greater effect on <strong>IoU</strong>.YOLO’s main source of error is incorrect localizations.</li></ol><hr><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><ul><li>R-CNN consists of three modules:  </li></ul><ol><li><strong>Generates category-independent region proposals</strong>.These proposal define the set of candidate bounding boxes <strong>available to our detector</strong>.  </li><li>A large convolutional neural network that extracts <strong>a fixed-length feature vector</strong> from each region.  </li><li>A set of <strong>class-specific linear SVMs</strong>. </li></ol><hr><h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><ul><li>R-CNN has notable drawbacks:  </li></ul><ol><li>Training is <strong>a multi-stage pipeline</strong>.  </li><li>Training is <strong>expensive</strong> in space and time.  </li><li>Object detection is <strong>slow</strong>.</li></ol><ul><li>Fast R-CNN’s advantages:  </li></ul><ol><li><strong>Higher detection quality(mAP)</strong> than R-CNN.  </li><li>Training is <strong>single-stage</strong>, using a <strong>multi-task loss</strong>.  </li><li>Training can <strong>update all network layers</strong>.  </li><li><strong>No disk storage</strong> is required for <strong>feature caching</strong>.  </li></ol><ul><li>A Fast R-CNN network takes as input <strong>an entire image</strong> and a set of <strong>object proposals</strong>.<br>The network first <strong>processes the whole image</strong> with several <strong>convolutional</strong> and <strong>max pooling layer</strong> to produce a <strong>conV feature map</strong>.<br>Then, for each object proposal a <strong>region of interest</strong> (<em>RoI</em>) pooling layer extracts <strong>fixed-length feature vector</strong> from the feature map.<br>Each feature vector is fed into a sequence of <strong>fully connected</strong> (<em>fc</em>) layers that finally branch into two sibling output layers:  </li></ul><ol><li>Produces <strong>softmax probability</strong> estimates over K object classes plus a catch-all “background” class.  </li><li>Outputs <strong>four real-valued numbers</strong> for each of the Kobject classes. Each set of 4 values encodes <strong>refined bounding-box positions</strong> for one of the K classes.</li></ol><hr><h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h2><ul><li>The paper introduces a <strong>Region Proposal Network</strong>(<em>RPN</em>) that shares <strong>full-image convolutional features</strong> with the <strong>detection network</strong>, thus enabling nearly <strong>cost-free</strong> region proposals.</li><li>An RPN is <strong>fully convolutional network</strong> that <strong>simultaneously</strong> predicts <strong>object bounds</strong> and <strong>objectness scores at each position</strong>. The RPN is trained <strong>end-to-end</strong> to generate high-quality <strong>region proposals</strong>, which are used by <strong>Fast R-CNN</strong> for detection.</li><li>Faster R-CNN merge <strong>RPN</strong> and <strong>Fast R-CNN</strong> into a single network by <strong>sharing their convolutional features</strong>–using the recently popular terminology of neural networks with <strong>“attention” mechanism</strong>, the RPN component tells the unified network <strong>where to look</strong>.</li></ul><hr><h2 id="R-CNN-Fast-R-CNN-and-Faster-R-CNN"><a href="#R-CNN-Fast-R-CNN-and-Faster-R-CNN" class="headerlink" title="R-CNN, Fast R-CNN and Faster R-CNN"></a>R-CNN, Fast R-CNN and Faster R-CNN</h2><h4 id="R-CNN-1"><a href="#R-CNN-1" class="headerlink" title="R-CNN:"></a>R-CNN:</h4><p><strong>Propose regions</strong> + <strong>classify proposed regions</strong> one at a time. Output <strong>label</strong> + <strong>bounding box</strong></p><h4 id="Fast-R-CNN-1"><a href="#Fast-R-CNN-1" class="headerlink" title="Fast R-CNN:"></a>Fast R-CNN:</h4><p><strong>Propose regions</strong>. Use <strong>convolution implementation</strong> of <strong>sliding windows</strong> to <strong>classify</strong> all the proposed regions.</p><h4 id="Faster-R-CNN-1"><a href="#Faster-R-CNN-1" class="headerlink" title="Faster R-CNN:"></a>Faster R-CNN:</h4><p>Use <strong>convolutional network</strong> to propose regions.</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes of Deep Learning Lessons:L4-CNN-Case Studies of CNN</title>
      <link href="2020/12/01/case-studies-of-cnn/"/>
      <url>2020/12/01/case-studies-of-cnn/</url>
      
        <content type="html"><![CDATA[<h2 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h2><ul><li>This paper is written in 1998,peple didn’t really use <strong>padding</strong> or using <strong>valid convolutions</strong>, so after applying ConV layer, the height and width shrinks.  </li><li>The <strong>architecture</strong> of LeNet is:<pre><code>ConV+pool-&gt;ConV+pool-&gt;FC-&gt;FC-&gt;output  </code></pre></li><li>LeNet uses <strong>sigmoid &amp; tanh</strong>, not <strong>ReLu</strong>.  </li><li>Graph Transformer Network(GTN) <strong>isn’t</strong> widely used today</li></ul><hr><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><ul><li>AlexNet has a lot of similarities to LeNet, but much <strong>bigger</strong>.(LeNet has 6w parameters and AlexNet has 6000w parameters).</li><li>AlexNet uses <strong>ReLu</strong> as its activation function.</li><li>Uses <strong>Data augmentation</strong> and <strong>Dropout</strong> to reduce overfitting. The first form of data augmentation consists of <strong>generating image translations</strong> and <strong>horizontal reflections</strong>, the second form of data augmentation consists of <strong>altering the intensities of RGB channels in training images</strong>.</li><li>When this paper is written ,GPUs were still a little bit slow, so it had a complicated way of training on <strong>2 GPUs</strong>.</li><li>Local Response Normalization(LRN) emphasized in this paper <strong>isn’t</strong> really used much.</li><li>It was really this paper that <strong>convinced a lot of CV community</strong> to take a serious look at Deep Learning and <strong>beyond</strong> CV as well.</li></ul><hr><h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><ul><li>Instead of having so many hyperparameters, VGG uses <strong>a simpler network</strong> focus just on ConV layers(ConV:3<em>3,s=1,same; MAX-POOL:2</em>2,s=2).This really simplified these NN architecture. </li><li>Number of parameters are vary <strong>large</strong>(138 Million).</li><li>This paper reveals the <strong>pattern</strong> of how as you go deeper, making the rate goes down and up <strong>systematic</strong>.</li><li>VGG confirm the importance of <strong>Depth</strong> in visual representations.</li></ul><hr><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><ul><li>In theory, having a deeper Network would help, but in practice, having a plain Network that is very deep means that <strong>your optimization algorithm has a harder training</strong>, and your training error gets worse, ResNet can produce no higher training error than its <strong>shallower counterpart</strong> and help you to solve this problem.</li><li>If the optimal function is closer to <strong>an identity mapping</strong> than to <strong>a zero mapping</strong>, it should be easier for the solver to find the perturbations with reference to <strong>an identity mapping</strong>, than to <strong>learn the function as a new one</strong>.The identy function is easy for residual block to learn since it is easy to get a[L+2] = a[L] because of this skip connection.</li><li>Assuming z[L+2] and a[L] have the same dimension, so actually this short-cut because same ConV preserves dimensions.</li><li>This paper focuses on <strong>the behavior of extremely deep Networks</strong>, not on pushing the state-of-art result, so uses simple architectures.  </li></ul><hr><h2 id="Network-in-Network"><a href="#Network-in-Network" class="headerlink" title="Network in Network"></a>Network in Network</h2><ul><li>With enhanced local modeling via the <strong>micro Network</strong>, we are able to utilize <strong>global average pooling</strong> over feature maps in the classification layer, which is easier to <strong>interpret</strong> and <strong>less prone to overfitting</strong> than traditional FClayers.</li><li>Even though the details of the architecture in this paper aren’t used widely, this idea of a *<em>1</em>1 convolution** or <strong>NIN</strong> idea has been very influential.  </li><li>This paper uses <strong>a micro Network</strong> structure to replace <strong>Generalized Linear Model</strong>(GLM).</li></ul><hr><h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><ul><li>Instead of choosing what filter size you want in ConV layers or pooling layers, you can do them all in the <strong>Inception module</strong>.</li><li>The Inception module uses *<em>1</em>1 ConV layer** to create a <strong>bottleneck layer</strong> to reducing the computational cost signigicantly.  </li><li>The main hallmark of this architecture is the <strong>improved utilization of the computing resources</strong> inside the Network. By a <strong>carefully crafted design</strong>, this paper <strong>increased the depth and width</strong> of the Network while <strong>keeping the computational budget constant</strong>.  </li><li>The most straightforward way of improving the performance of deep Neural Network is by <strong>increasing their size</strong>. This includes both increasing the <strong>depth</strong> - the number of Network levels - as well as its <strong>width</strong>: the number of units at each level. However, this simple solution comes with two major drawbacks:<br>1.Bigger size typically means a larger number of parameters, which makes the enlarged Network more prone to overfitting.<br>2.The dramatically increased use of computational resources.<br>A fundamental way of solving both of these issues would be to introduce <strong>sparsity</strong> and <strong>replace the FC layers by sparse ones</strong>, even inside the convolutions.<br>If the <strong>probability distribution</strong> of the dataset is representable by a large, very sparse deep Neural Network, then the optimal Network topology can be constructed <strong>layer after layer</strong> by <strong>analyzing the correlation statistics</strong> of the preceding layer activations and <strong>clustering neurons</strong> with highly correlated outputs.</li><li>The main idea of the <strong>Inception architecture</strong> is to consider how an optimal local sparse structure of a convolutional vision Network can be <strong>approximated</strong> and <strong>covered</strong> by <strong>readily available dense components</strong>.</li><li>The design follows the practical intuition that visual information should be <strong>processed at various scales</strong> and then <strong>aggregated</strong> so that the next stage can abstract features from the diffrent scales simultaneously.</li><li>The function of the branches in GoogLeNet is to take some hidden layers and try to use that to <strong>make a prediction</strong>. It helps ensure that the feature’s computed even in the hidden layers or intermediate layers. This appears to have a <strong>regularizing effect</strong> on the Inception Network and prevent this Network from <strong>overfitting</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用指南</title>
      <link href="2020/10/20/markdown-shi-yong-zhi-nan/"/>
      <url>2020/10/20/markdown-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p></blockquote><h2 id="1-Why-Markdown"><a href="#1-Why-Markdown" class="headerlink" title="1.Why Markdown"></a>1.Why Markdown</h2><ul><li>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。  </li><li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。  </li><li>当前许多网站都广泛使用 Markdown来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。  </li></ul><hr><h2 id="2-测试实例"><a href="#2-测试实例" class="headerlink" title="2.测试实例"></a>2.测试实例</h2><p>Markdown编写Hello World！语法：</p><pre><code># Hello World!</code></pre><p>显示效果如下：  </p><h2 id="Hello-World！"><a href="#Hello-World！" class="headerlink" title="Hello World！"></a>Hello World！</h2><hr><h2 id="3-Markdown标题"><a href="#3-Markdown标题" class="headerlink" title="3.Markdown标题"></a>3.Markdown标题</h2><p>Markdown标题有两种格式：</p><h4 id="使用-和-标记一级和二级标题"><a href="#使用-和-标记一级和二级标题" class="headerlink" title="使用=和-标记一级和二级标题"></a>使用=和-标记一级和二级标题</h4><p>=和-标记语法格式如下：  </p><pre><code>我展示的是一级标题====我展示的是二级标题----</code></pre><p>显示效果如下：  </p><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题  "></a>我展示的是一级标题  </h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题  "></a>我展示的是二级标题  </h2><h4 id="使用-号标记"><a href="#使用-号标记" class="headerlink" title="使用#号标记"></a>使用#号标记</h4><p>使用#号可以表示1-6级标题，一级标题对应一个<code>#</code>号，二级标题对应两个<code>#</code>号，依此类推</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>显示效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="4-Markdown段落"><a href="#4-Markdown段落" class="headerlink" title="4.Markdown段落"></a>4.Markdown段落</h2><p>Markdown段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车</strong>  </p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗体文本___</code></pre><p><em>斜体文本</em>  </p><p><em>斜体文本</em>  </p><p><strong>粗体文本</strong>  </p><p><strong>粗体文本</strong>  </p><p><strong><em>粗斜体文本</em></strong>  </p><p><strong><em>粗斜体文本</em></strong>  </p><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。你也可以在星号或者是减号中间插入空格。下面每种写法都可以建立分隔线</p><pre><code>**** * ******- - ------</code></pre><p>显示效果如下：</p><hr><hr><hr><hr><hr><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个<code>~~</code>即可，实例如下：</p><pre><code>GOOGLE.COM~~BAIDU.COM~~</code></pre><p>显示效果如下：<br>GOOGLE.COM<br><del>BAIDU.COM</del></p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>下划线可以通过HTML的<code>&lt;u&gt;</code>标签来实现：</p><pre><code>&lt;u&gt;带下划线的文本&lt;/u&gt;</code></pre><p>显示效果如下：<br><u>带下划线的文本</u></p><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注是对文本的补充说明。<br>Markdown脚注的格式如下：  </p><pre><code>[^要注明的文本]</code></pre><p>以下实列演示了脚注的用法：  </p><pre><code>创建脚注的格式类似这样 [^RUNOOB]。[^RUNOOB]:菜鸟教程--学的不仅是技术，更是梦想！</code></pre><p>演示效果如下：<br>创建脚注的格式类似这样:[^RUNOOB]。<br>[^RUNOOB]:此处为脚注演示 </p><hr><h2 id="5-Markdown列表"><a href="#5-Markdown列表" class="headerlink" title="5.Markdown列表"></a>5.Markdown列表</h2><p>Markdown支持有序列表和无序列表<br>无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项+ 第一项+ 第二项- 第一项- 第二项</code></pre><p>显示效果如下：  </p><ul><li>第一项  </li><li>第二项    </li></ul><ul><li>第一项  </li><li>第二项   </li></ul><ul><li>第一项  </li><li>第二项  </li></ul><p>有序列表使用数字加上<code>.</code>号来表示，如：</p><pre><code>1.第一项2.第二项3.第三项</code></pre><p>显示效果如下：<br>1.第一项<br>2.第二项<br>3.第三项  </p><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre><code>1.第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2.第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>显示效果如下：<br>1.第一项：  </p><ul><li>第一项嵌套的第一个元素  </li><li>第一项嵌套的第二个元素  </li></ul><p>2.第二项：  </p><ul><li>第二项嵌套的第一个元素  </li><li>第二项嵌套的第二个元素  </li></ul><hr><h2 id="6-Markdown区块"><a href="#6-Markdown区块" class="headerlink" title="6.Markdown区块"></a>6.Markdown区块</h2><p>Markdown区块引用是在段落的开头使用<code>&gt;</code>符号，然后后面紧跟着一个<strong>空格</strong>符号：</p><pre><code>&gt;区块引用&gt;菜鸟教程&gt;学的不是技术更是梦想</code></pre><p>显示结果如下：  </p><blockquote><p>区块引用<br>菜鸟教程<br>学的不是技术更是梦想  </p></blockquote><p>另外区块也是可以嵌套的，一个<code>&gt;</code>符号是最外层，两个<code>&gt;</code>符号是第一层的嵌套，以此类推：  </p><pre><code>&gt;最外层&gt;&gt;第一层嵌套&gt;&gt;&gt;第二层嵌套</code></pre><blockquote><p>最外层  </p><blockquote><p>第一层嵌套  </p><blockquote><p>第二层嵌套  </p></blockquote></blockquote></blockquote><h4 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h4><p>区块中使用列表实例如下：</p><pre><code>&gt;区块中使用列表&gt;1.第一项&gt;2.第二项&gt;+ 第一项&gt;+ 第二项&gt;+ 第三项</code></pre><p>显示结果如下：</p><blockquote><p>区块中使用列表<br>1.第一项<br>2.第二项  </p></blockquote><blockquote><ul><li>第一项  </li><li>第二项  </li><li>第三项  </li></ul></blockquote><h4 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h4><p>如果要在列表项目内放进区块，那么就需要在<code>&gt;</code>前添加四个空格的缩进。<br>区块中使用列表实例如下：</p><pre><code>·第一项    &gt;菜鸟教程    &gt;学的不仅是技术更是梦想·第二项</code></pre><p>显示结果如下：  </p><ul><li>第一项  <blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想  </p></blockquote></li><li>第二项  </li></ul><hr><h2 id="7-Markdown代码"><a href="#7-Markdown代码" class="headerlink" title="7.Markdown代码"></a>7.Markdown代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(```),例如：</p><pre><code>`print()` 函数</code></pre><p>显示结果如下：  </p><p><code>print()</code> 函数</p><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>代码区块<br>代码区块使用<strong>四个空格</strong>或者一个**制表符(Tab键)**。<br>实例如下：  </p><pre><code>    &lt;?php      echo 'RUNOOB';      function test(){          echo 'test'      }  </code></pre><p>显示结果如下：  </p><pre><code>&lt;?php  echo 'RUNOOB';  function test(){      echo 'test'  } </code></pre><p>你也可以使用`````包裹一段代码，并指定一种语言(也可以不指定)：</p><pre><code>```javascript$(document).ready(function){    alert('RUNOOB');})</code></pre><p>显示结果如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'RUNOOB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><hr><h2 id="8-Markdown链接"><a href="#8-Markdown链接" class="headerlink" title="8.Markdown链接"></a>8.Markdown链接</h2><p>链接使用方法如下：  </p><pre><code>[链接名称]（链接地址）或者&lt;链接地址&gt;</code></pre><p>例如：</p><pre><code>这是一个链接 [菜鸟教程](httpd://runoob.com)</code></pre><p>显示结果如下：<br>这是一个链接 <a href="httpd://runoob.com">菜鸟教程</a><br>直接使用地址链接：  </p><pre><code>&lt;https://www.runoob.com&gt;</code></pre><p>显示结果如下：<br><a href="https://www.runoob.com/">https://www.runoob.com</a>  </p><h4 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h4><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code>这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [runoob]: http://www.runoob.com/</code></pre><p>显示结果如下：<br>这个链接用 1 作为网址变量 [Google][1]<br>这个链接用 runoob 作为网址变量 [Runoob][runoob]<br>然后在文档的结尾为变量赋值（网址）<br>[1]:<a href="http://www.google.com/">http://www.google.com/</a><br>[runoob]:<a href="http://www.runoob.com/">http://www.runoob.com/</a></p><h2 id="9-Markdown图片"><a href="#9-Markdown图片" class="headerlink" title="9.Markdown图片"></a>9.Markdown图片</h2><p>Markdown图片语法格式如下：</p><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题")</code></pre><p>开头一个感叹号，接着一个方括号，里面放上图片的替代文字，接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例：  </p><pre><code>![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png "RUNOOB")</code></pre><p>显示结果如下：<br><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然你也可以像网址那样对图片网址使用变量：</p><pre><code>这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png</code></pre><p>显示结果如下：<br>这个链接用 1 作为网址变量 [RUNOOB][1].<br>然后在文档的结尾为变量赋值（网址）<br>[1]: <a href="http://static.runoob.com/images/runoob-logo.png">http://static.runoob.com/images/runoob-logo.png</a>  </p><p>Markdown还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的<img>标签。  </p><pre><code>&lt;img src="http://static.runoob.com/images/runoob-logo.png" width="50%"&gt;</code></pre><img src="http://static.runoob.com/images/runoob-logo.png" width="50%"><hr><h2 id="10-Markdown表格"><a href="#10-Markdown表格" class="headerlink" title="10.Markdown表格"></a>10.Markdown表格</h2><p>Markdown制作表格使用<code>|</code>来分割不同的单元格，使用<code>-</code>来分割表头和其他行。<br>语法格式如下：  </p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>以上代码显示结果如下：  </p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对其方式<br><strong>我们可以设置表格的对齐方式：</strong>  </p><ul><li><code>-:</code>设置内容和标题栏居右对齐  </li><li><code>:-</code>设置内容和标题栏居左对齐  </li><li><code>:-:</code>实质内容和标题栏居中对齐  </li></ul><p>实例如下：</p><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-| -: | :-: || 单元格111 | 单元格111 | 单元格111 || 单元格 | 单元格 | 单元格 |</code></pre><p>以上代码显示结果如下：  </p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格111</td><td align="right">单元格111</td><td align="center">单元格111</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><hr><h2 id="11-Markdown高级技巧"><a href="#11-Markdown高级技巧" class="headerlink" title="11.Markdown高级技巧"></a>11.Markdown高级技巧</h2><h4 id="支持的HTML元素"><a href="#支持的HTML元素" class="headerlink" title="支持的HTML元素"></a>支持的HTML元素</h4><p>不在Markdown涵盖范围内的标签，都可以直接在文档里面用HTML撰写。<br>目前支持的 HTML元素有： &lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;br&gt;等， 如：  </p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>输出结果为：<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑  </p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：  </p><pre><code>**文本加粗**\*\*正常显示星号 \*\*</code></pre><p>输出结果为：<br><strong>文本加粗</strong><br>**正常显示星号 **<br>Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First Airticle</title>
      <link href="2020/10/17/my-first-airticle/"/>
      <url>2020/10/17/my-first-airticle/</url>
      
        <content type="html"><![CDATA[<p>还不会写md嘻嘻</p>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Daily </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
